import ldap
import os
import pritunlsdk
from pritunl import logger

{% if ('True' or 'true') in (pritunl_plugins | selectattr("name","equalto","ldap") | map(attribute='enable_graylog') | join) %}

import graypy
import logging

graylog_server = "{{pritunl_plugins | selectattr("name","equalto","graylog") | map(attribute='server') | join }}"
graylog_port = {{pritunl_plugins | selectattr("name","equalto","graylog") | map(attribute='port') | join }}

class OpsLogging(object):
    """Ops Logger - An Logging subsystem """
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.logger.setLevel(logging.INFO)
        self.handler = None
        self.logger_adapter = None

    def setup(self, server, port):
        if not server or not port:
            return False

        self.handler = graypy.GELFHandler(server,
                                          port,
                                          debugging_fields=False)

        self.logger.addHandler(self.handler)

    def _print_dict(self, msg_string, msg_dict):
        """Send dict to graylog (custom field)."""
        self.logger_adapter = logging.LoggerAdapter(self.logger, msg_dict)
        self.logger_adapter.info(msg_string,msg_dict)

logger = OpsLogging()
logger.setup(graylog_server,graylog_port)

{% endif %}

class LDAPSearch(object):
    """ It  provides a simple way to performs synchronous LDAP queries.
    README https://github.com/chaordic/python-ldap-simple-search
     """
    _conn = None

    def __init__(self,
                 uri,
                 bind_dn,
                 password):

        ldap.set_option(ldap.OPT_REFERRALS, 0)
        self.uri = uri
        self.bind_dn = bind_dn
        self.password = password

    def __del__(self):
        self._unbind()

    def conn(self):
        if self._conn is None:
            self._conn = self._bind()
        return self._conn

    def _bind(self):
        l = ldap.initialize(self.uri)
        l.protocol_version = ldap.VERSION3
        l.set_option(ldap.OPT_NETWORK_TIMEOUT, 10.0)
        try:
            l.simple_bind_s(self.bind_dn, self.password)
        except ldap.INVALID_CREDENTIALS:
            logger.error('Your username or password is incorrect.')
            raise
        except ldap.LDAPError as e:
            if type(e.message) == dict and 'desc' in e.message:
                logger.error(e.message['desc'])
            else:
                logger.error(e)
            raise
        return l

    def _unbind(self):
        if self._conn is not None:
            self.conn().unbind_s()
            self._conn = None

    def search(self,
               base_dn,
               searchFilter,
               searchAttribute=None,
               callback=None):
        try:
            ldap_result_id = self.conn().search(
                                        base_dn,
                                        ldap.SCOPE_SUBTREE,
                                        searchFilter,
                                        searchAttribute)
            result_set = []
            while 1:
                result_type, result_data = self.conn().result(ldap_result_id, 0)
                if (result_data == []):
                    break
                else:
                    if result_type == ldap.RES_SEARCH_ENTRY:
                        result_set += self._handleResults(result_data, callback)
            self._unbind()
            return result_set
        except ldap.LDAPError as e:
            self._unbind()
            if type(e.message) == dict and 'desc' in e.message:
                logger.error(e.message['desc'])
            else:
                logger.error(e)
            raise

    def _handleResults(self, data, callback):
        results = []

        for dn, record in data:
            if dn is not None:
                if callback is not None:
                    results = callback(dn, record)
                else:
                    results.append((dn, record))

        return results

os.environ["PRITUNL_API_URL"] = "{{ pritunl_api.url }}"
os.environ["PRITUNL_API_TOKEN"] = "{{ pritunl_api.token }}"
os.environ["PRITUNL_API_SECRET"] = "{{ pritunl_api.secret }}"

PRITUNL_ORG = "{{ pritunl_api.organization }}"
GROUP_PATTERN = "{{pritunl_plugins | selectattr("name","equalto","ldap") | map(attribute='group_pattern') | join }}"

URI = "{{pritunl_plugins | selectattr("name","equalto","ldap") | map(attribute='uri') | join }}"
BIND_DN = "{{pritunl_plugins | selectattr("name","equalto","ldap") | map(attribute='bind_dn') | join }}"
PASSWORD = "{{pritunl_plugins | selectattr("name","equalto","ldap") | map(attribute='password') | join }}"
BASE_DN = "{{pritunl_plugins | selectattr("name","equalto","ldap") | map(attribute='base_dn') | join }}"
GROUPS_DN = "{{pritunl_plugins | selectattr("name","equalto","ldap") | map(attribute='groups_dn') | join }}"
SEARCH_ATTRIBUTE = ['{{pritunl_plugins | selectattr("name","equalto","ldap") | map(attribute='search_attribute') | join }}']

L = LDAPSearch(URI, BIND_DN, PASSWORD)

def filter_groups(dn, record):
    """ LDAPSearch callback """
    return [item.split(',')[0].replace('cn=', '') for item in record['memberOf'] if GROUP_PATTERN in item]

def sso_authenticate(sso_type, host_id, host_name, user_name, user_email,
                     remote_ip, sso_org_names, sso_group_names, **kwargs):
    """ Pritunl handler """

    default_group = []
    search_filter = "(&(mail="+user_name+")(memberOf=cn="+GROUP_PATTERN+"*,"+GROUPS_DN+"))"

    ldap_groups = L.search(BASE_DN, search_filter,
                           SEARCH_ATTRIBUTE, filter_groups)
    if 'auth_ok':
        if ldap_groups:
            pritunlsdk.post_pritunl_user(PRITUNL_ORG,user_name,user_groups=ldap_groups)
            logger.info("Associate groups %s to user '%s'" % (ldap_groups,user_name))
        else:
            logger.info("Cannot find LDAP user. Associate 'vpn-all' group to user '%s'" % (ldap_groups,user_name))
            default_group = ['vpn-all']
        return True, '', default_group
    else:
        return False, None, None
